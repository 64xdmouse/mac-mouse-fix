//
// --------------------------------------------------------------------------
// MFDataClass.m
// Created for Mac Mouse Fix (https://github.com/noah-nuebling/mac-mouse-fix)
// Created by Noah Nuebling in 2024
// Licensed under Licensed under the MMF License (https://github.com/noah-nuebling/mac-mouse-fix/blob/master/License)
// --------------------------------------------------------------------------
//

#import "MFDataClass.h"
@import ObjectiveC.runtime;
#import "MFDataClassDictionaryDecoder.h"

@implementation MFDataClassBase

/// General Notes:
/// Notes on handling primitive properties:
///     The KVC API (`valueForKey:` and `setValue:forKey`) automatically wraps (and unwraps) numbers and structs in `NSNumber` or `NSValue` objects.
///         Source: Apple Docs: KeyValueCoding - Representing Non-Object Values: https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE
///     `NSValue` (and its subclass `NSNumber`) also adopt the `NSCopying` and `NSSecureCoding` protocols. On top of this, NSValue also implements the`hash` and `isEqual:`methods in a proper way (and it works even if you box custom structs - From my limited testing).
///     -> Because of this, we don't need much primitive-value-specific code - NSValue and KVC does it all for us!
///         (Where 'primitive-value' refers to any non-object value that KVC is compatible with, such as c numbers and structs. Other c types like unions don't work with KVC I heard, and therefore might break `MFDataClass`.) (Update: We now validate inside `+ load` that there are no unions.)

/// Definitions

/// isclass macro
/// Behavior:
///     isclass(x, classname) works on both normal objects and class objects.
///         If `x` is a normal object:                  Checks whether *the class of x*  is equivalent to, or a subclass of, the class called `classname`
///         If `x` is a class-object:                    Checks whether *x itself*             is equivalent to, or a subclass of, the class called `classname`
///         -> Therefore, this replaces both isKindOfClass: and isSubclassOfClass:
/// Why does this work?
///     On a normal object:    `class` returns the class-object, and `object_getClass()` also returns the class-object.
///     On a class-object:       `class` returns the class-object, but `object_getClass()` returns the *meta-class-object*.
/// Performance:
///     Not how much slower this is compared to isKindOfClass: or isSubclassOfClass:. Prolly not significant.

#define isclass(x, classname) [[(x) class] isKindOfClass:object_getClass([classname class])]

// MARK: (Almost) compile time validation

+ (void)onLoadValidation {
    
    /// Validate definition of this MFDataClass
    ///     Ideally we'd be able to do this validation while, or even before compilation. But that's not possible, so doing it in `+ load` in DEBUG builds is the next best thing.
    ///     Notes:
    ///     - We invoking this in `+ load` in the code generated by the `MFDataClassImplementX()` macros.
    ///     - We're using `#if DEBUG` instead of `runningPrerelease()` because I'm not sure that would slow down app start time in release builds. (Should maybe test this). Also I think `#if DEBUG` is enough since this should catch any issues with MFDataClass definitions every time the app launches, so I don't ever need to ship this to users to catch issues.
    ///     - We're using `[NSException raise]` because that seems to be the only way to crash the program while writing a message into the crashReport. (Update: Why is that important though?) I also heard about a technique using the `__crashreporter_info__` global var but haven't looked into it much.
    ///             Update: In the CFRelease() source code I saw CRSetCrashLogMessage(). Could we use that?
    ///             Sidenote: The CFRelease() source code contains a really interesting method for detecting recursion: Taking the address of goto-labels and comparing them to `__builtin_return_address(0)`.  (I used NSThread dicts when I needed to detect recursion which might be much slower –– But I also saw there's the `static __thread` storage modifier for more lightweight thread-local storage.)
    ///     - Should/could we validate against somebody trying to subclass an MFDataClass without using the MFDataClassX() macros? That might be possible by having [MFDataClassBase +load] find and iterate all its subclasses and then applying this validation. But since I'm working on this project alone, I won't make that mistake.
    
    #if DEBUG
    
    /// Log
    NSLog(@"Validating MFDataClass: %@", self); /// Using NSLog since I don't know if DDLog works in `+ load`.
    
    /// Validate superclass
    
    Class superclass = class_getSuperclass([self class]);
    if (!isclass(superclass, MFDataClassBase)) {
        [NSException raise:MFDataClassInvalidDefinitionException format:@"MFDataClass '%@' does not seem to inherit from MFDataClassBase. Superclass is '%@'.", self, superclass];
    }
    Class classToCheck = superclass;
    while (true) {
        
        /// Get propertyCount
        unsigned int propertyCount;
        free(class_copyPropertyList(classToCheck, &propertyCount));
        
        /// Validate
        if (propertyCount > 0) {
            [NSException raise:MFDataClassInvalidDefinitionException format:@"MFDataClass '%@' inherits from a class with more than 0 properties (%@). This would break the autogenerated initializers. Compose MFDataClass instances together into nested structures instead of inheriting from an MFDataClass with more than 0 properties.", self, classToCheck];
        }
        
        /// Break
        if (classToCheck == MFDataClassBase.class) { break; } /// Found MFDataClassBase
        if (classToCheck == nil || classToCheck == NSObject.class) { assert(false); break; } /// Found root class, this can never happen (as of Oct 2024)
        
        /// Iterate
        classToCheck = class_getSuperclass(classToCheck);
        
    }
    
    /// Validate properties
    for (NSString *propertyName in self.allPropertyNames) {

        /// Get typeEncoding
        NSString *propertyAttributes = [self attributesForProperty:propertyName];
        NSString *typeEncoding = typeEncodingForProperty(propertyAttributes);
        if (typeEncoding == nil) {
            [NSException raise:NSInternalInconsistencyException format:@"Couldn't get type encoding for property %@.%@ with attributes %@ (This should never happen, no matter how the MFDataClass is defined.)", self, propertyName, propertyAttributes];
        }
        
        /// Validate nullable/nonnull property attribute
        ///     Keep in mind: (Oct 2024)
        ///         This validates the nullability that's passed into the `@implementation` macro (`MFDataClassImplementX()`)
        ///         But meanwhile, all the native objc warnings as well as the way that the dataclass is imported into Swift depends on the nullability specified in the `@@interface` macro (`MFDataClassInterfaceX()`)
        ///         -> ! Keep the nullability in the `@@implementation` and `@@interface` macros synchronized!
        ///             ... otherwise, these validations here won't ensure correctness.
        BOOL isNullableType = propertyHasTypeThatSupportsNullability(typeEncoding);
        NSString *rawNullability = [self rawNullabilityOfProperty:propertyName];
        if (rawNullability == nil) {
            [NSException raise:NSInternalInconsistencyException format:@"Raw nullability string of property %@.%@ was nil. (This should never happen, no matter how the MFDataClass is defined.)", self, propertyName];
        }
        if (isNullableType && ([rawNullability isEqual:@""] || [rawNullability isEqual:@"null_unspecified"])) {
            [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ has unspecified nullability (raw nullability value: '%@') even though its type supports nullability. Due to the existence of NS_ASSUME_NONNULL, we cannot know at runtime whether the property is nullable or not if nullability is not specified. This could (theoretically) lead to bugs and inconsistencies because we won't be able to validate nullability inside `initWithCoder:`. Please explicitly specify the nullability in the MFDataClass definition to fix this.", self, propertyName, rawNullability];
        } else if (!isNullableType && ![rawNullability isEqual:@""]) {
            [NSException raise:NSInternalInconsistencyException format:@"Property %@.%@ has specified nullability even though its type does not support nullability. This should never happen (since the objc compiler doesn't even let you compile when you do this afaik)", self, propertyName];
        }
        if ([rawNullability isEqual:@"null_resettable"]) {
            [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ has null_resettable attribute. Don't know how to handle this. Needs additional testing.", self, propertyName];
        }
        
        /// Note: We don't need to validate the readwrite/readonly property attribute since there's nothing to do wrong there.
        /// Note: We don't need to validate the assign/strong/weak/copy property attributesince the objc compiler already validates the necessary stuff (objc doesn't let you use assign with objects, but forces you to use assign with non-objects)
        
        /// Validate property type
        NSString *propClassName = classNameForProperty([typeEncoding cStringUsingEncoding:NSUTF8StringEncoding]);
        
        if (propClassName != nil) {
            
            /// Property is an object
            if ([propClassName isEqual:@"id"]) { /// Our `classNameForProperty:` returns `id` to signal that the className is unspecified.
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ has an unspecified class type (likely declared using `id`.) Use a concrete class like `NSObject` instead. Otherwise we can't run type validation when decoding an instance of this object, and so we cannot decode using NSSecureCoding.", self, propertyName];
            }
            
            Class theClass = NSClassFromString(propClassName);
            if (theClass == nil) {
                [NSException raise:NSInternalInconsistencyException format:@"Failed to instantiate class for property %@.%@. propertyAttributes: %@, className: %@. Not sure if this can ever happen.", self, propertyName, propertyAttributes, propClassName];
            }
            
            NSArray<Protocol *> *protocols = @[@protocol(NSSecureCoding),
                                               @protocol(NSCopying),
                                               @protocol(NSObject)]; /// We can't really confirm that the object properly implements `isEqual:` since that's part of the `NSObject` protocol which everybody implements;
            
            for (Protocol *protocol in protocols) {
                if (![theClass conformsToProtocol:protocol]) {
                    [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with class %@ does not conform to protocol: %@. This would silently break protocol conformance of the MFDataClass (%@). Please use another type for the property.", self, propertyName, propClassName, protocol, self];
                }
            }
            
        } else {
        
            /// Property is non-object-type
            ///     -> Check if we know how to handle this type
            ///     -> What we reallyyy want to know is whether Key-Value-Coding will auto-box these types in NSValue. If that's the case everything should work.
            ///         (Because NSValue adopts all the protocols we want: `NSSecureCoding`, `NSCopying`, `NSObject`)
            ///         -> However, I don't know how to check exactly which types will get autoboxed in NSValue. So these tests are kinda based on my gut feeling and stuff.
            ///
            ///     Documentation of c-type encodings:
            ///         1.NSHipster:  https://nshipster.com/type-encodings/
            ///         2. Apple Docs: https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1
            
            ///     Note that we're disallowing many c types
            ///         ... but we let any **structs** and **numbers** pass.
            ///         Numbers should always work. (They're always auto-boxed in `NSNumber` by KVC)
            ///         Structs are normally auto-boxed by KVC. But I suspect that some complex structs with won't be supported? I don't know how to check that, though.
            
            /// Remove the leading 'const' encoding (r)
            ///     Observation: const is only encoded for some types it seems.
            ///     I saw r be part of the objc encoding of `const char *` (which is `r*`). But for `const NSString *`, const seems to be ignored in the type encoding. Didn't test how `const int` is encoded.
            if ([typeEncoding characterAtIndex:0] == 'r') typeEncoding = [typeEncoding substringFromIndex:1];
            
            /// Extract chars
            unichar chars[typeEncoding.length];
            [typeEncoding getCharacters:chars];
            
            if ([typeEncoding isEqual:@"@?"]) { /// block ptr
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a block pointer.   Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding isEqual:@"^?"]) { /// function ptr
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a function ptr.    Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding isEqual:@"^v"]) { /// void ptr
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a void pointer.    Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if (chars[0] == '^') { /// any ptr
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a raw pointer.     Not sure how to handle that", self, propertyName, typeEncoding];
            
            } else if (chars[0] == '(') { /// union
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a union.           They are incompatible with KVC afaik.", self, propertyName, typeEncoding];
            
            } else if (chars[0] == '[') { /// c array
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a c array.         Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if (chars[0] == '*') { /// c string
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a raw c string.    Not sure how to handle that. Probably use NSString instead.", self, propertyName, typeEncoding];
            
            } else if (chars[0] == 'b') { /// bit field
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a bit field.       Not sure how to handle that", self, propertyName, typeEncoding];
            
            } else if (chars[0] == '#') { /// Class object
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a class object.    Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if (chars[0] == ':') { /// SEL
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a SEL.             Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if (chars[0] == '?') { /// Unknown
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be 'unknown'.         Not sure how to handle that.", self, propertyName, typeEncoding];
            }
        }
    }
    
    #endif
}

// - MARK: Protocol implementations

// MARK: NSSecureCoding protocol

+ (BOOL)supportsSecureCoding {
    /// I think we only support secureCoding if all properties have types that also conform to `NSSecureCoding`? Not sure what happens if this is not the case. But I thinkkk it would just fail gracefully, and still work when we turn `.requiresSecureCoding` off.
    ///     Update: In `+ load` we now do validation that properties support `NSSecureCoding`.
    return YES;
}

- (void)encodeWithCoder:(NSCoder *)coder { /// You don't call these encoding/decoding methods directly, instead you use an NSCoder subclass or (`MFEncode()` / `MFDecode()`)
    for (NSString *key in self.class.allPropertyNames) {
        id value = [self valueForKey:key];
        if (value) {
            [coder encodeObject:value forKey:key];
        }
    }
}
    
- (instancetype)initWithCoder:(NSCoder *)coder {
    
    /// Also see:
    ///     Apple WWDC 2018 Session 222 "Data You Can Trust": https://devstreaming-cdn.apple.com/videos/wwdc/2018/222krhixqaeggyrn33/222/222_hd_data_you_can_trust.mp4?
    ///         (This has been deleted from the Apple page for some reason, but their CDN still has the video)
    ///         -> This explains how and why to use `NSSecureCoding`
    ///
    /// On `NSSecureCoding`: (Last updated: Oct 2024)
    ///     I thought about this a bit and I think NSSecureCoding and how Apple communicates it is a bit weird / ineffective.
    ///     As I understand the core problem, basically there's a possibility that, between encoding and decoding an object, the encoded data could be manipulated by attackers in malicious ways. (serialization attack)
    ///     1. First of all, when your encoded data comes from a controlled, trusted source, (like from the user's library as it is the case for the config.plist file of Mac Mouse Fix), then validating the high level data like this is unnecessary.
    ///         That's because accidental data corruption would result in an invalid archive with extremely high likelyhood, so if you successfully unarchived your entire object graph, any further validation is only helpful for guarding against *deliberate* tampering by hackers - which is not a concern if the data comes from a trusted source.
    ///     2. Secondly, the `NSSecureCoding` documentation only speaks about validating that the decoded object's `classes` are what you expect.
    ///         However, this is not enough to prevent malicious tampering. For example if you decode a URL, that could be replaced by a hacker with a phishing URL and even if you implement `NSSecureCoding` exactly as advertised by Apple, that wouldn't help at all.
    ///         For some reason Apple only focuses on class-substitution attacks with `NSSecureCoding`.
    ///             There is one thing that's special about class-substitution-attacks which warrants implementing a special API, but doesn't seem to warrant focusing the entire `NSSecureCoding` protocol around it and pushing everyone to adopt it:
    ///                 The thing that's special is that: For all other types of validation except for matching-class-validation, you can make the decoding watertight against attackers by validating the decoded values *after* they come out of the decoder.
    ///                 But when decoding objects, their `- init` or `+ load` methods could already produce side-effects before you can validate whether the object is of the right class.
    ///                 -> So this opens a possible attack vector, (which would be very hard to do anything useful with since the hacker could still only instantiate classes which are already defined in your application, and could only work with their `- initWithCoder`, `+ initialize` or `+ load` methods.)
    ///                     This attack-vector cannot be closed by traditional validation methods where you validate the class *after* it comes out of the decoder so that's why `NSCoder - decodeObjectOfClass:` exists. It makes sense.
    ///     -> So I understand why `decodeObjectOfClass:` exists - it makes it possible to make your decoding process *totally* watertight against attackers, *if* you use it alongside more extensive validation.
    ///     -> But the only thing that `NSSecureCoding` does is tell/require you to use `decodeObjectOfClass:`. And Apple seems to basically push everybody to use `NSSecureCoding` all the time.
    ///         This doesn't make sense to me because:
    ///         If you have a trusted source for the data, `decodeObjectOfClass:`/`NSSecureCoding` is basically entirely unnecessary.
    ///         If you have an untrusted source, just adopting `decodeObjectOfClass:`/`NSSecureCoding` is by far not enough to make things really watertight against attacks, but Apple doesn't seem to mention this in the `NSSecureCoding` docs.
    ///
    /// About the validation we do here: (Last updated: Oct 2024)
    ///     For `MFDataClass` we're validating **nullability** and **type** of every decoded property.
    ///     As explained in the `NSSecureCoding` section, this is pretty unnecessary unless we're decoding data from an untrusted source.
    ///     If we are decoding data from an untrusted source, then we should probably do additional, custom validation, because the nullability and type checks are not enough to make things actually secure.
    ///         -> We could do additional, custom validation by creating a category for an `MFDataClass`.)
    ///         -> Untrusted data is not a concern for Mac Mouse Fix currently.
    ///             But perhaps in the future it will be? E.g. if we promote sharing config.plist files between users?
    ///             Update: [Jan 2025] Actually, we are dealing with untrusted data because anyone can send data to our message ports.
    ///
    /// Update:
    ///     Actually, I can think of another reason that our nullability and type validation could be useful aside from protecting against hacker attacks: When you change the layout of an MFDataClass between MMF versions.
    ///     In this case, ideally you would version your MFDataClasses and then validate that the version number matches. However, in the absence of deliberate versioning, our nullability and type checks should at least prevent loading of outdated MFDataClasses from producing any crashes in the code due to unexpected nil values or unexpected types inside the MFDataClass.
    ///         However there could still be problems, so we should probably version our MFDataClasses.
    ///         TODO: (Should maybe update our MFDataClass macros to include a version arg.)
    ///
    
    if (isclass(coder, MFDataClassDictionaryDecoder)) {
        
        /// Get MFDataClass to instantiate from the dict archive (if we're decoding an MFDataClass hierarchy from a nested dictionary)
        ///     On letting the dict specify the class to instantiate: [Jan 2025]
        ///         If this fails, we could theoretically fall back to just creating an instance of self.class.
        ///         but that's bad in case our code expects us to instantiate a specific *subclass* of self.class. (That's the case for MFLicenseTypeInfo, where we never wanna instantiate the 0-prop base class, only its subclasses.)
        ///
        ///     On architecture: [Feb 2025]
        ///         We could possibly move all the MFDataClassDictionaryDecoder-specific code into MFDataClassDictionaryDecoder. Then MFDataClassDictionaryDecoder might be able to decode any kind of class-hierarchy from a nested dictionary. (Not just MFDataClasses)
        ///         ... But doing it like this was easier and works for our purposes.
        ///         ... Also, the idea originally was that MFDataClassDictionaryDecoder does as little as possible and essentially just wraps an NSDictionary. Maybe it's a good idea to keep it that way.
        
        
        id __tmp = coder;
        MFDataClassDictionaryDecoder *coder = __tmp;
        if (![coder containsValueForKey:MFDataClass_DictArchiveKey_ClassName]) {
            [coder failWithError:[NSError errorWithDomain:NSCocoaErrorDomain code:NSCoderInvalidValueError userInfo:@{ @"message": stringf(@"MFDataClass name missing from the dictionary archive (%@).", coder.underlyingDict) }]];
            return nil;
        }
        NSString *clsName = [coder decodeObjectOfClass:NSString.class forKey:MFDataClass_DictArchiveKey_ClassName];
        if (coder.error != nil) {
            return nil; /// We don't need to failWithError: here since the coder already has an error.
        }
        Class cls = NSClassFromString(clsName);
        if (!cls) {
            [coder failWithError:[NSError errorWithDomain:NSCocoaErrorDomain code:NSCoderInvalidValueError userInfo:@{ @"message": stringf(@"No class object currently loaded for MFDataClass name '%@' which is specified in dictionary archive (%@)", clsName, coder.underlyingDict) }]];
            return nil;
        }
        if (!isclass(cls, self.class)) {
            [coder failWithError:[NSError errorWithDomain:NSCocoaErrorDomain code:NSCoderInvalidValueError userInfo:@{ @"message": stringf(@"The MFDataClass retrieved from the dictionary archive (%@) is not a subclass of the class we're trying to initialize (%@)", cls, self.class) }]];
            return nil;
        }
        
        /// Turn self into an instance of cls
        if (cls != self.class) {
            self = [cls alloc];
            if ((0)) {
                /// Why do this instead of just setting `self = [cls alloc]` and then letting our method continue?
                ///     Pro: Ensure correctness in case cls has a custom implementation of `initWithCoder:`
                ///         Also note: The [super init] call below might call the wrong implementation in this case. That's because super is resolved at compile time. However, if cls had a custom initWithCoder: implementation, we'd already be running the wrong implementation by this point, so the super resolution is a moot point.
                ///     Contra: This is a bit inefficient, since `initWithCoder:` checks self.class against `MFDataClass_DictArchiveKey_ClassName` again.
                ///     Contra: We probably never need a custom `initWithCoder:` implementation – the goal is to share 1 generic impl across all MFDataClasses)
                self = [self initWithCoder:coder];
                return self;
            }
        }
    }
    
    self = [super init];
    if (!self) return nil;
    
    for (NSString *key in self.class.allPropertyNames) {
        
        /// Declare partial results
        id _Nullable decodeValueResult;
        Class expectedClass_DataClassNotDict = nil; /// If we're decoding a nested dictionary into an MFDataClass hierarchy, this stores the MFDataClass that `decodeValueResult` should be converted into (if it is a dictionary.)
        
        /// Non-secure decoding
        ///  -> Do absolutely no validation -> Should be a bit faster. Can't think of other reasons to use this. Not sure the speed ever matters.
        if (!coder.requiresSecureCoding) {
            decodeValueResult = [coder decodeObjectForKey:key];
        }
        
        /// Guard valueNotFound
        if (coder.requiresSecureCoding) {
            if (![coder containsValueForKey:key]) {
                assert(false);
                [coder failWithError:[NSError errorWithDomain:NSCocoaErrorDomain code:NSCoderValueNotFoundError userInfo:@{ @"message": stringf(@"No value found for key while decoding %@.%@", [self class], key) }]];
                return nil;
            }
        }
        
        /// Get typeinfo for the self.key property
        NSString *typeEncoding;     /// The type of the self.key property
        BOOL isNonObjectValue = 0;  /// Whether self.key is an object or of primitive type. || Initializing this to silence compiler warnings (which don't make sense)
        Class expectedClass;        /// The class of the object we're expecting to retrieve from the archive for "key"
        
        if (coder.requiresSecureCoding ||
            (isclass(coder, MFDataClassDictionaryDecoder) && isclass(decodeValueResult, NSDictionary))) /// If we're decoding a nested dictionary into an MFDataClass hierarchy, and we decoded a dictionary for `key`, then we need to determine the type of the self.key property to know whether to convert the decoded dictionary into an MFDataClass instance.
        {
            /// Get typeEncoding
            NSString *propertyAttributes = [[self class] attributesForProperty:key];
            typeEncoding = typeEncodingForProperty(propertyAttributes);
            
            /// Guard no typeEncoding
            ///     Note: We already validate this in the onLoadValidation -> Remove this.
            if (typeEncoding == nil) {
                assert(false);
                [coder failWithError:[NSError errorWithDomain:@"MFPlaceholderErrorDomain" code:123456789 userInfo:@{ @"message": stringf(@"Internal inconsistency: Couldn't get typeEncoding for property %@.%@ with attributes: %@", [self class], key, propertyAttributes) }]];
                return nil;
            }
            
            /// Get className
            NSString *className = classNameForProperty([typeEncoding cStringUsingEncoding:NSUTF8StringEncoding]);
            
            /// Edge case: unspecified object type
            ///     If the property is declared with an unspecified object type, then our type validation code won't work.
            ///     We're already validating this in `+ load` - so this should never happen.
            ///     Note: We already validate this in the onLoadValidation -> Remove this.
            if ([className isEqual:@"id"]) {
                assert(false);
                [coder failWithError:[NSError errorWithDomain:@"MFPlaceholderErrorDomain" code:123456789 userInfo:@{ @"message": stringf(@"Internal inconsistency: Property %@.%@ with attributes: %@ seems to have unspecified object type (likely declared with `id`).", [self class], key, propertyAttributes) }]];
                return nil;
            }
            
            /// Parse className
            isNonObjectValue = className == nil; /// If the className is nil, that means the property is a non-object value - that's how our `classNameForProperty()` function works.
            
            /// Get expectedClass
            if (isNonObjectValue)  {
                expectedClass = [NSValue class]; /// Non-object values come out of our decoder boxed inside an NSValue (That's because when *en*coding an MFDataClass instance, we use the KVC API to get the property values, and this API auto-boxes non-object values in `NSValue`, and so that's how we pass them into the encoder.)
            } else {
                expectedClass = NSClassFromString(className);
            }
            
            /// Override expected class if we're decoding an MFDataClass hierarchy from a nested dictionary.
            if (isclass(coder, MFDataClassDictionaryDecoder)    &&
                isclass(expectedClass, MFDataClassBase)         )
            {
                expectedClass_DataClassNotDict = expectedClass;
                expectedClass = [NSDictionary class];
            }
        }
        
        if (coder.requiresSecureCoding) {
            
            /// Note: Omg KVC has a method `validateValue:forKey:error:`! Maybe that could've replaced all this stuff? ... Nope that's for custom validation, not auto-validation. See https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/ValidatingProperties.html#//apple_ref/doc/uid/10000107i-CH18-SW1
            
            /// Decode value
            ///     (Using NSSecureCoding method)
            ///     The decoder will `failWithError:` automatically, if there's a type mismatch or the decoded object does not implement `NSSecureCoding`.
            ///     -> That is, if `coder.requiresSecureCoding == true`
            ///     -> If `coder.requiresSecureCoding == false` then this would do no checks while decoding the object. `expectedClass` would be ignored.
        
            id _Nullable value = [coder decodeObjectOfClass:expectedClass forKey:key];
            
            /// Guard decoding error
            ///     Depending on the `coder.decodingFailurePolicy`, `decodeObjectOfClass:` might either throw and error or just set `coder.error` and then continue execution, so we check for that here.
            if (coder.error != nil) {
                assert(false);
                return nil; /// We don't need to call `failWithError:` since the coder already has an error.
            }
            
            /// Check type
            if (((0)) && !coder.requiresSecureCoding) { /// Why `((0))`?: If `requiresSecureCoding` is true, `decodeObjectOfClass:` will have already checked the type, so we can skip this. Update: These checks are not helpful if `requiresSecureCoding` is turned off. See the discussion above on `NSSecureCoding`
                if (value != nil && ![value isKindOfClass:expectedClass]) {
                    assert(false);
                    [coder failWithError:[NSError errorWithDomain:NSCocoaErrorDomain code:NSCoderInvalidValueError userInfo:@{ @"message": stringf(@"Type mismatch while decoding %@.%@: Expected: %@. Found: %@", [self class], key, expectedClass, [value class]) }]];
                    return nil;
                }
            }
            
            /// Get nullability
            BOOL isAllowedToBeNil = [[self class] propertyIsAllowedToBeNil:key];
            
            if ((value == nil) && !isAllowedToBeNil) {
                assert(false);
                [coder failWithError:[NSError errorWithDomain:NSCocoaErrorDomain code:NSCoderInvalidValueError userInfo:@{ @"message": stringf(@"Unexpectedly found nil while decoding non-nullable property %@.%@.", [self class], key) }]];
                return nil;
            }
            
            /// Check boxed type
            if (isNonObjectValue) {
            
                /// Cast to NSValue
                NSValue *nsValue = (NSValue *)value;
                
                /// Get type encodings
                const char *propertyTypeEncoding = [typeEncoding cStringUsingEncoding:NSUTF8StringEncoding];
                const char *nsValueTypeEncoding = [nsValue objCType];
                
                /// Special case: Booleans
                if (strcmp(propertyTypeEncoding, "B") == 0) { /// For boolean properties, the decoded NSValue seems to just use 'c' (char) while the property encoding uses 'B' (boolean). I also checked `ivar_getTypeEncoding()` and it's also `B` so won't help. Possible explanation: This Apple doc says that BOOL is char on macOS for historical reasons: https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE
                    propertyTypeEncoding = "c";
                }
                
                /// Check if types match
                if (strcmp(nsValueTypeEncoding, propertyTypeEncoding) != 0) {
                    assert(false);
                    [coder failWithError:[NSError errorWithDomain:NSCocoaErrorDomain code:NSCoderInvalidValueError userInfo:@{ @"message": stringf(@"Type mismatch while decoding non-object property %@.%@. Expected: %s. Found: %s", [self class], key, propertyTypeEncoding, nsValueTypeEncoding) }]];
                    return nil;
                }
            }
            
            /// Passed all security checks!
            decodeValueResult = value;
        }
        
        /// Convert dict to MFDataClass
        ///     In case we're decoding a nested dictionary into an MFDataClass hierarchy
        if (isclass(coder, MFDataClassDictionaryDecoder)    &&
            expectedClass_DataClassNotDict != nil           &&
            isclass(decodeValueResult, NSDictionary)        &&  /// This is redundant, I think (Except maybe if this can be nil?)
            isclass(expectedClass, NSDictionary)            &&  /// This is redundant [Feb 2025]
            1                                               )
        {
            /// Create MFDataClass instance
            ///     Note: `initWithDictionary:` creates a new coder. Couldn't we reuse the current coder somehow? Usually only 1 coder is used during decoding I think.
            NSError *err;
            decodeValueResult = [((MFDataClassBase *)[expectedClass_DataClassNotDict alloc]) initWithDictionary:decodeValueResult
                                                                                            requireSecureCoding:coder.requiresSecureCoding
                                                                                                          error:&err];
            if (err) {
                [coder failWithError:err];
                return nil;
            }
            
        }
        
        /// Store the decoded value inside the self.key property
        [self setValue:decodeValueResult forKey:key];
    }
    
    return self;
}

// MARK: NSCopying Protocol
- (id)copyWithZone:(NSZone *)zone {
    
    /// Notes:
    /// - By copying all properties, we do a 'deeper' copy than e.g. `[NSArray -copy]`.
    ///     Perhaps we can rationalize this by thinking: MFDataClass is like an "object-version" of a struct. Structs behave like they are 'deep-copying', so MFDataClass should, as well. Also, shallow copying and then swapping / adding some members to the copy feels more useful on NSArray, since it's a 'more dynamic' datatype (?)
    /// - (Oct 2024) Immutable values can just return themselves instead of a copy and noone will notice. Could we determine whether we are immutable and leverage that for optimization? (We probably could by checking `property_getAttributes()` for whether all our properties are `readonly`.)

    MFDataClassBase *copy = [[[self class] allocWithZone:zone] init];
    if (copy) {
        for (NSString *key in self.class.allPropertyNames) {
            id value = [self valueForKey:key];
            if (value) {
                [copy setValue:[value copyWithZone:zone] forKey:key]; /// Non-object-specific logic is not necessary, since `NSValue` and `NSNumber` (which our non-object values will be boxed in by KVC) adopt the `NSCopying` protocol. But also, NSNumber and NSValue are immutable so `- copyWithZone:` might just `return self` and not do anything and not cause any overhead?
            }
        }
    }
    return copy;
}

// MARK: Override NSObject Equality/Hashing methods:
- (BOOL)isEqual:(id)object {
    
    /// Trivial cases
    if (object == nil) {
        return NO;
    }
    if (self == object) {
        return YES;
    }
    if (object_getClass(self) != object_getClass(object)) { /// Note: Is this a valid way to compare class-equality? TODO: Check our Swizzling code to see how we do it there.
        return NO;
    }
    
    /// Unwrap other
    MFDataClassBase *other = (MFDataClassBase *)object;
        
    /// Compare hash
    ///     Disabling because: At best this would be an optimization, but i think it might slow things down here. Also if the class matches, we already know the hash matches, since the hash is independent of internal object state (As of Nov 2024)
    if ((0) &&
        [self hash] != [other hash])
    {
        return NO;
    }
    
    /// Compare internal state
    if (![self.internalStateForEqualityComparison isEqual:other.internalStateForEqualityComparison]) {
        return NO;
    }
    
    /// Passed all tests!
    return YES;
}
- (NSObject *_Nonnull)internalStateForEqualityComparison {

    /// Client code can override this (in a category) to easily change the definition of equality between two instances of the same MFDataClass
    ///     On nil:
    ///         If you override this with an NSArray of propertyValues, don't forget to substitute nil values with `[NSNull null]`. Trying to insert nil into an array will crash and stuff!
    ///
    ///     Background: (Nov 2024)
    ///         We made this method primarily so we have one simple way to update both `-isEqual` and `-hash` correctly.
    ///         However, we've since made `-hash` independent of internal instance state, so this doesn't affect `-hash` anymore.
    ///         Therefore, now, it might be better to just override `-isEqual` directly instead of overriding this? Maybe we should remove this?
    ///         Idea: Maybe we could replace this with an easily overridable `isEqualToDataClass:` method, which is called by `isEqual:` (similar to NSString's `isEqualToString:`)
    
    return [self allPropertyValues];
}

- (NSUInteger)hash {

    /// Why use propertyCount as -hash?
    ///     - `-hash` needs to not change while an object is in a collection. For mutable objects, this can only be achieved by a) not putting them into collections b) making hash independent of the mutable internal state of the object.
    ///         - Src: `-hash` docs: https://developer.apple.com/documentation/objectivec/1418956-nsobject/1418859-hash
    ///     - NSDictionary also simply uses the number of elements as its hash. So this should be ok.
    ///
    /// If you need a real hash:
    ///     (... that depends on the instance's internal state), you can encode the instance to data and then use Apple's crypto frameworks.

    NSUInteger propertyCount = [[[self class] allPropertyNames] count];
    return propertyCount;
}

/// MARK: Override NSObject description

- (NSString *)description {

    NSString *content = @"";
    NSArray<NSString *> *propNames = [self.class allPropertyNames];
    if (propNames.count > 0) {
    
        /// Check for circular refs
        ///     This prevents infinite loops if there are circular references in the datastructure. But [NSDictionary -description] seems to just infinite-loop in this case... Maybe this was overkill.
        NSMutableArray *visitedObjects = threadlocal(NSMutableArray);
        NSNumber *s = @((uintptr_t)self); /// We cast self to an NSNumber so that we effectively do pointer-based equality checking instead of using the full `-isEqual` implementation.
        BOOL didFindCircularRef = [visitedObjects containsObject:s];
        [visitedObjects addObject:s];
        MFDefer ^{
            assert([[visitedObjects lastObject] isEqual:s]);
            [visitedObjects removeLastObject];
        };
        
        /// Get description of props
        if ((0)) {
            content = [self asDictionaryWithRequireSecureCoding:NO].description;
        } else if (didFindCircularRef) {
            content = @"<This object has appeared in the description before. Stopping here to prevent infinite recursion.>";
        } else {
            NSMutableString *_content = [NSMutableString string];
            
            for (int i = 0; i < propNames.count; i++) {
                NSString *name = propNames[i];
                NSString *_Nullable value = [[self valueForKey:name] description]; /// If this is nil, NSString will just insert "(null)" iirc || `-description` is the recursive call that might cause infinite loops if there are circular refs
                [_content appendFormat:@"%@: %@", name, value];
                bool isNotLast = (i < propNames.count - 1);
                if (isNotLast) {
                    [_content appendString:@"\n"];
                }
            }
            content = _content;
        }
    }
    
        
    /// Assemble result
    NSString *(^addIndent)(NSString *) = ^(NSString *input) {
        return [input stringByReplacingOccurrencesOfString:@"(\n|^)(.)" /// Match the string start (`^`) and line breaks (`\n`) if they're followed by at least one character (`.`) (That way we skip empty lines)      (General regex explanation: Parentheses `(...)` create a 'capture group')
                                                withString:@"$1    $2"  /// Insert spaces between 1: the string-start / line break (`\n|^`) and 2: the first character of the line (`.`)                                                   (General regex explanation: `$2` is a 'backreference' to the 2nd 'capture group')
                                                   options:NSRegularExpressionSearch
                                                     range:NSMakeRange(0, input.length)];
    };
    NSString *result;
    if ([content containsString:@"\n"]) {
        result = stringf(@"<%@> {\n%@\n}", NSStringFromClass(self.class), addIndent(content));
    } else {
        result = stringf(@"<%@> {%@}", NSStringFromClass(self.class), content);
    }
    
    /// Return
    return result;
}

/// MARK: Utility
+ (NSArray<NSString *> *_Nonnull)allPropertyNames {
    
    /// Notes:
    /// - On caching:
    ///     This is used by almost all other methods - We could maybe do some caching here to speed things up
    ///     But don't forget: If we do a naive cache and just return the same NSArray every time, then this will break if properties are added at runtime.
    ///     (Update: [Feb 2025] I'm pretty sure we never ever wanna add properties at runtime to an MFDataClass. Perhaps we would use `objc_setAssociatedObject()` to do something similar.)
    
    NSMutableArray *result = [NSMutableArray array];
    
    unsigned int propertyCount, i;
    objc_property_t *properties = class_copyPropertyList([self class], &propertyCount);
    MFDefer ^{ free(properties); };
    
    for (i = 0; i < propertyCount; i++) {
        const char *propName = property_getName(properties[i]);
        if (propName) [result addObject:@(propName)]; /// Converting to NSString every time might be a bit slow?
    }
    
    return result;
}

- (NSArray<id> *_Nonnull)allPropertyValues {

    ///     On property order: (Nov 2024)
    ///         The order of these property values needs to always be the same, otherwise `-isEqual:` will break.
    ///         I think it should be fine since the underlying function `class_copyPropertyList()` seems to output the properties in deterministic order based on my testing.
    ///         If order ever does cause breakage, perhaps we could sort the propertyValues or change our `-isEqual:` logic.
    
    NSMutableArray *result = [NSMutableArray array];
    
    for (NSString *propertyName in self.class.allPropertyNames) {
        id propertyValue = [self valueForKey:propertyName];
        propertyValue = propertyValue ?: [NSNull null]; /// Adding nil into an array causes an exception!
        [result addObject:propertyValue];
    }
    
    return result;
}

/// MARK: - Property analysis
///     We use this for validation in `- initWithCoder:`
///     Big picture: (As of Oct 2024)
///         Here, we implement functions to analyze **nullability** and **type** of a property.
///         This is quite a bit of code, but it is really only really used for validation of the decoded data inside `initWithCoder:`
///         - but this validation might not even be helpful in practise -> See discussion inside `initWithCoder:` for more.
///     Sidenote:
///         (We're technically also using this property analysis stuff inside the `+ load` validation, but the `+ load` validation just validates that the `initWithCoder:` validation is going to work.)


/// Convenience macro
///     This mainly servers as an example of the entire 'analysis-chain'. We break it up into many small functions for efficiency – so we can reuse the partial results.
#define classForPropertyName(classobject, propname)                     \
    NSClassFromString(                                                  \
        classNameForProperty(                                           \
            [typeEncodingForProperty(                                   \
                [(classobject) attributesForProperty:(propname)]        \
            ) cStringUsingEncoding:NSUTF8StringEncoding]                \
        )                                                               \
    )                                                                   \

NSString *_Nullable typeEncodingForProperty(NSString *_Nullable propertyAttributes) {
    
    /// Get type encoding for a string obtained with `property_getAttributes()`
    ///     See the Apple docs for an explanation of the attributeString format: https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101
    ///     Discussion:
    ///         The docs linked above seem to be outdated. They claim that between the first `T` and `,` of a property's attribute string (obtained with `property_getAttributes()`) you'll find the `@encode()` string of the property's type.
    ///         However, there seems to be a discrepancy, as `@encode()` always just returns `@` for any object, while the property's attribute string will contain additional information about the class and protocols of a given object.
    ///         For example you might find the following substring in the attribute string:`@"T@"NSView<NSSecureCoding><NSCopying>",`. If the docs were accurate this should instead just be `@"T@,`, because `@encode()` just returns `@`.
    
    /// Check nil
    if (propertyAttributes == nil) return nil;
    
    /// Extract the type encoding string
    NSInteger typeEncodingPre = [propertyAttributes rangeOfString:@"T" options:NSLiteralSearch].location;
    NSInteger typeEncodingPost = [propertyAttributes rangeOfString:@"," options:NSLiteralSearch].location;
    if (typeEncodingPre == NSNotFound || typeEncodingPost == NSNotFound) {
        assert(false); /// I think this should never happen unless objc runtime is broken or we got a wrong input value
        return nil;
    }
    NSInteger typeEncodingStart = typeEncodingPre + 1;
    NSInteger typeEncodingEnd = typeEncodingPost - 1;
    NSInteger typeEncodingLen = typeEncodingEnd - typeEncodingStart + 1;
    
    if (typeEncodingLen < 0) {
        assert(false); /// Type encoding has less than zero characters. Don't think this can ever happen except if objc runtime is broken or we get wrong input. Think this can only happen if `,` occurs before `T` in the string.
        return nil;
    }
    
    NSRange typeEncodingRange = NSMakeRange(typeEncodingStart, typeEncodingLen);
    NSString *typeEncoding = [propertyAttributes substringWithRange:typeEncodingRange];
    
    /// Return
    return typeEncoding;
}

+ (NSString *_Nullable)attributesForProperty:(NSString *_Nullable)propertyName {
    if (propertyName == nil) return nil;
    objc_property_t property = class_getProperty(self, [propertyName cStringUsingEncoding:NSUTF8StringEncoding]); /// Why UTF8? Quote from Objective-C runtime docs: `All char * in the runtime API should be considered to have UTF-8 encoding.`
    if (property == nil) return nil;
    const char *attributes = property_getAttributes(property);
    if (attributes == NULL) return nil;
    return @(attributes);
}

// MARK: NSDictionary & JSON conversion

/// (Note: [Jan 2025] Disabled the JSON conversion code, since it was unused.
///     When we did wanna create an MFDataClass based on JSON, we wrote a specialized function for that MFDataClass which used `asDictionaryWithRequireSecureCoding:` under the hood.)
#if 0
    - (NSData *_Nullable)asJSONWithRequireSecureCoding:(BOOL)requireSecureCoding error:(NSError *__autoreleasing _Nullable *_Nullable)errorPtr {
        NSDictionary *dict = [self asDictionaryWithRequireSecureCoding:requireSecureCoding];
        NSData *result = [NSJSONSerialization dataWithJSONObject:dict options:0 error:errorPtr];
        return result;
    }

    - (instancetype _Nullable)initWithJSON:(NSData *_Nonnull)jsonData requireSecureCoding:(BOOL)requireSecureCoding error:(NSError *__autoreleasing _Nullable * _Nullable)errorPtr {
        if (!jsonData) return nil;
        NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:errorPtr];
        if (!dict) return nil;
        self = [self initWithDictionary:dict requireSecureCoding:requireSecureCoding error:errorPtr];
        return self;
    }
#endif

- (NSDictionary<NSString *, NSObject *> *_Nonnull)asDictionaryWithRequireSecureCoding:(BOOL)requireSecureCoding {
    
    /// Creates a dictionary archive of the MFDataClass hierarchy starting at self
    ///     (exactly in the format that [self initWithDictionary:] expects)
    /// Note: We used to use the standard KVC method `dictionaryWithValuesForKeys:` but it cannot recursively convert nested hierarchies of MFDataClass objects.
    
    NSMutableDictionary *resultDict = [NSMutableDictionary dictionary];

    for (NSString *propName in self.class.allPropertyNames) {
        id value = [self valueForKey:propName];
        if (requireSecureCoding && ![value conformsToProtocol:@protocol(NSSecureCoding)])
            assert(false && "The value doesn't support secure coding. Don't think this should ever happen since we're already validating this in `+ load`."); /// We don't throw fancy errors. This is just so that, during development, we don't accidentally decide to encode stuff we can't decode later.
        if (!value) value = NSNull.null; /// [Jan 2025] Represent nil with NSNull in the dict. MFDataClassDictionaryDecoder does the inverse conversion.
        if (isclass(value, MFDataClassBase)) value = [(MFDataClassBase *)value asDictionaryWithRequireSecureCoding:requireSecureCoding]; /// Recurse
        resultDict[propName] = value;
    }
    
    resultDict[MFDataClass_DictArchiveKey_ClassName] = NSStringFromClass(self.class);
    
    return resultDict;
}

- (instancetype _Nullable)initWithDictionary:(NSDictionary *_Nonnull)dict requireSecureCoding:(BOOL)requireSecureCoding error:(NSError *__autoreleasing _Nullable * _Nullable)errorPtr {
    
    /// Create an instance from a dictionary.
    ///     If `requireSecureCoding` is enabled, then all of the validation mechanisms from `initWithCoder:` are turned on.
    ///     Values that should be nil are expected to be `NSNull` in the dict.
    
    if (!dict) { assert(false); return nil; }
    
    if ((0) && !requireSecureCoding) {
        
        /// Note: Why did we write an extra codepath for non-validated decoding? ... disabled this codepath.
        /// TODO: Delete this
        assert(false); /// Untested.
        
        /// Non-validated decode
        ///     Note: We used to use `setValuesForKeysWithDictionary:` here. It's a standard KVC method, meant to be the inverse of `dictionaryWithValuesForKeys:`, but it can't handle nested hierarchies of MFDataClass instances.
        self = [super init];
        if (!self) return nil;
        
        for (NSString *propName in self.class.allPropertyNames) {
            id value = dict[propName];
            if (value == nil)           assert(false && "The dictionary archive didn't have a value defined for all property names. The dictionary archive is probably invalid or outdated.");
            if (value == NSNull.null)   value = nil;
            if (isclass(value, NSDictionary)) {
                Class propClass = NSClassFromString(classNameForProperty([typeEncodingForProperty([self.class attributesForProperty:propName]) cStringUsingEncoding:NSUTF8StringEncoding]));
                if (isclass(propClass, MFDataClassBase)) {
                    value = [((MFDataClassBase *)[propClass alloc]) initWithDictionary:value requireSecureCoding:NO error:errorPtr]; /// Recurse.
                    if (errorPtr && *errorPtr) return nil; /// Not totally sure this is appropriate. I mean if secure coding is disabled, initWithDictionary: doesn't set any errors anyways?
                }
            }
            [self setValue:value forKey:propName];
        }
        
        return self;
        
    } else {
    
        /// Decode using `initWithCoder:`
        NSCoder *decoder = [[MFDataClassDictionaryDecoder alloc] initForReadingFromDict:dict requiresSecureCoding:requireSecureCoding];
        self = [self initWithCoder:decoder];
        if (errorPtr) *errorPtr = decoder.error;
        return self;
    }
}

/// MARK: Property-nullability analysis

+ (BOOL)propertyIsAllowedToBeNil:(NSString *)propertyName {
    
    NSString *nullabilityString = [self rawNullabilityOfProperty:propertyName];
    BOOL result = [nullabilityString isEqual:@"nullable"];
    
    return result;
    
    /// Notes:
    ///     We used to do more complex stuff here,
    ///         but now we're validating a lot of nullability stuff in `load` making it unnecessary.
    ///
    ///     Here are the old notes from when we did more complex stuff:
    ///     The raw `nullabilityString` can be empty (`@""`).
    ///     The meaning of this is ambiguous:
    ///         For non-nullable types the nullabilityString has to be empty.
    ///         For nullable types, we assume that emptyString means that the property is nullable.
    ///         -> However, this would break if `NS_ASSUME_NONNULL` was set where the MFDataClass was defined. In that case emptyString would mean the property is nonnull, and we couldn't detect this here.
    ///     Update:
    ///         Now, inside `+ load`, we validate that the nullabilityString is empty if and only if the property type does *not* support nullability. For types that support nullability, nullability needs to be specified explicitly. This gets rid of the ambiguity of `@""`, letting us simplify this code a lot.
}

+ (NSString *_Nullable)rawNullabilityOfProperty:(NSString *_Nullable)propertyName {
    ///
    /// Returns stringified version of the nullability attribute - exactly as it's been passed into the `MFDataClassX(...)` macro.
    ///
    /// Possible outputs:
    ///     ```
    ///     - @"nullable"
    ///     - @"nonnull"
    ///     - @"null_resettable"        (Don't use this with MFDataClass)
    ///     - @"null_unspecified"       (Don't use this with MFDataClass)
    ///     - @""                       (We return this if: Nullability was left empty in the property definition)
    ///     - nil                       (We return this if: No property was found for `propertyName`)
    ///     ```
    ///
    /// We just raise an exception / return nil here because implementing this properly here is impossible.
    /// Instead we override this method in the `MFDataClassImplementX()` macros.
    /// -> That's necessary because nullability info is not accessible through objc runtime introspection.
    /// -> Info about *all other* property attributes seems to be available through runtime introspection (e.g. whether the property is `strong`, `assign`, `nonatomic`, what type it has, etc.)
    ///     -> That other info can be accessed at runtime through `property_getAttributes()`
    ///
    /// On nullable input:
    ///     We use the `propertyName` input value as a dictionary-key in the subclass overrides of this method. When indexing an NSDictionary with nil it seems to just returns nil. So this should be safe.
    
    [NSException raise:NSInternalInconsistencyException format:@"MFDataClassX(...) macros must override %@ without calling super.", NSStringFromSelector(_cmd)];
    return nil; /// This line will never be reached
}

/// MARK: Property-type analysis

BOOL propertyHasTypeThatSupportsNullability(NSString *_Nullable typeEncoding) {
    
    /// Discussion:
    ///     As far as I know, object pointers and regular pointers support nullability, but nothing else does.
    ///     Object pointers are identified in the type encoding by `@`, while pointers are identified by `^` (or `*` for c strings)
    ///     Interesting/special cases are function pointers (identified by `^?`) and block pointers (identified by `@?`). - those are also nullable. I don't think anything else is.
    ///     Note that opaque types like `CFStringRef` are actually struct pointers, so their type encoding will contain `^`, so this function will also categorize them as 'supports nullability' which is correct.
    
    if (typeEncoding == nil || typeEncoding.length == 0) {
        assert(false);
        return NO;
    }
    
    unichar chars[typeEncoding.length];
    [typeEncoding getCharacters:chars];
    
    unichar c = chars[0];
    if (c == 'r') c = chars[1]; /// Skip lead 'const' encoding.
    BOOL result = c == '^' || c == '@' || c == '*';
    
    return result;
}

NSString *_Nullable classNameForProperty(const char *_Nullable typeEncoding) {
    
    /// This gets the objc class name for a string obtained with `typeEncodingForProperty()`
    ///
    /// Possible outputs:
    ///     1. The class name for the @property whose type encoding is `typeEncoding`
    ///     2. `@"id"` (if the property is an object of unspecified type)
    ///         (Note that `id` is not a valid class name and will produce nil when passed to `NSClassFromString()`. In contrast, all other non-nil return values should produce valid `Class` object when passed to `NSClassFromString()`)
    ///     3. `nil` (if the property has a non-object type, or no property was found for `propertyName`)
    ///
    ///     Examples:
    ///         - For an *object* property:
    ///             `@property (strong, nonatomic) NSString *coolString;`
    ///             This function would return  `@"NSString"`
    ///
    ///         - For a *non-object* property:
    ///             `@property (assign, nonatomic) int coolInt;`
    ///             This function would return `nil`
    ///
    ///         - For a property with *protocol conformance*:
    ///             `@property (strong, nonatomic) NSObject<NSSecureCoding, NSCopying> *coolCodableObject;`
    ///             This function would strip out the protocol info and return `@"NSObject"`
    ///
    ///         - For a property with unspecified object type (id):
    ///             `@property (strong, nonatomic) id<NSCopying> coolCopyingObject;`
    ///             This function would return `@"id"`
    ///
    /// TODO: Perhaps use NSScanner instead of this low-level c-string stuff
    ///     (Might be easier.)
    
    
    /// Check NULL
    if (typeEncoding == NULL) { /// `strlen()` segfaults if you pass it NULL
        return nil;
    }
        
    /// Extract the classEncoding from the typeEncoding
    ///     Or return nil if the typeEncoding does not describe a class (If it does describe a class it follows the format `@"..."`)
    long typeEncodingLen = strlen(typeEncoding);
    if (typeEncodingLen < 3) return nil;
    if (typeEncoding[0] != '@' || typeEncoding[1] != '"' || typeEncoding[typeEncodingLen-1] != '"') return nil;
    char classEncoding[typeEncodingLen - 2]; /// The classEncoding buffer will contain the typeEncoding string minus the `@`, `"`, and `"` characters, plus a zero-terminator (`'\0'`)
    strncpy(classEncoding, typeEncoding + 2, typeEncodingLen - 3);
    classEncoding[typeEncodingLen - 3] = '\0';
    
    /// Remove protocol conformance information
    ///     Sidenote:
    ///         Protocol conformance (such as `NSObject<NSSecureCoding> *`) shows up in the `typeEncoding`
    ///         But generic types (such as `NSArray<NSString *> *`) do *not* show up in the `typeEncoding`
    ///         -> even though both use very similar syntax, generics seem to be compile-time-only
    char *protocolInfoStartCharPtr = strchr(classEncoding, '<');
    if (protocolInfoStartCharPtr != NULL) {
        long protocolInfoStartIdx = protocolInfoStartCharPtr - classEncoding;
        classEncoding[protocolInfoStartIdx] = '\0'; /// Cut the string short by inserting a zero-terminator (This is overcomplicated, we could just do `*charPtr = '\0'` to achieve the same thing)
    }
    
    /// Guard empty string
    ///     Empty `classEncoding` means the type is an object of unspecified type
    if (strlen(classEncoding) == 0) return @"id";
    
    /// Validate
    assert(NSClassFromString(@(classEncoding)) != nil);
    
    /// Return
    return @(classEncoding);
}

@end
