//
// --------------------------------------------------------------------------
// MFDataClass.m
// Created for Mac Mouse Fix (https://github.com/noah-nuebling/mac-mouse-fix)
// Created by Noah Nuebling in 2024
// Licensed under Licensed under the MMF License (https://github.com/noah-nuebling/mac-mouse-fix/blob/master/License)
// --------------------------------------------------------------------------
//

#import "MFDataClass.h"
@import ObjectiveC.runtime;

@implementation MFDataClassBase

/// General Notes:
/// Notes on handling primitive properties:
///     The KVC API (`valueForKey:` and `setValue:forKey`) automatically wraps (and unwraps) numbers and structs in `NSNumber` or `NSValue` objects.
///         Source: Apple Docs: KeyValueCoding - Representing Non-Object Values: https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE
///     `NSValue` (and its subclass `NSNumber`) also adopt the `NSCopying` and `NSSecureCoding` protocols. On top of this, NSValue also implements the`hash` and `isEqual:`methods in a proper way (and it works even if you box custom structs - From my limited testing).
///     -> Because of this, we don't need much primitive-value-specific code - NSValue and KVC does it all for us!
///         (Where 'primitive-value' refers to any non-object value that KVC is compatible with, such as c numbers and structs. Other c types like unions don't work with KVC I heard, and therefore might break `MFDataClass`.) (Update: We now validate inside `+ load` that there are no unions.)

// MARK: (Almost) compile time validation

+ (void)onLoadValidation {
    
    /// Validate definition of this MFDataClass
    ///     Ideally we'd be able to do this validation while, or even before compilation. But that's not possible, so doing it in `+ load` in DEBUG builds is the next best thing.
    ///     Notes:
    ///     - We invoking this in `+ load` in the code generated by the `MFDataClassImplementX()` macros.
    ///     - We're using `#if DEBUG` instead of `runningPrerelease()` because I'm not sure that would slow down app start time in release builds. (Should maybe test this). Also I think `#if DEBUG` is enough since this should catch any issues with MFDataClass definitions every time the app launches, so I don't ever need to ship this to users to catch issues.
    ///     - We're using `[NSException raise]` because that seems to be the only way to crash the program while writing a message into the crashReport. (Update: Why is that important though?) I also heard about a technique using the `__crashreporter_info__` global var but haven't looked into it much.
    
    #if DEBUG
    
    /// Log
    NSLog(@"Validating MFDataClass: %@", self); /// Using NSLog since I don't know if DDLog works in `+ load`.
    
    /// Validate superclass
    
    Class superclass = class_getSuperclass([self class]);
    if (![superclass isKindOfClass:object_getClass(MFDataClassBase.class)]) { /// `object_getClass()` gets the 'metaclass' of the class, letting us use `isKindOfClass:` on a class instead of an instance.
        [NSException raise:MFDataClassInvalidDefinitionException format:@"MFDataClass '%@' does not seem to inherit from MFDataClassBase. Superclass is '%@'.", self, superclass];
    }
    Class classToCheck = superclass;
    while (true) {
        
        /// Get propertyCount
        unsigned int propertyCount;
        free(class_copyPropertyList(classToCheck, &propertyCount));
        
        /// Validate
        if (propertyCount > 0) {
            [NSException raise:MFDataClassInvalidDefinitionException format:@"MFDataClass '%@' inherits from a class with more than 0 properties (%@). This would break the autogenerated initializers. Compose MFDataClass instances together into nested structures instead of inheriting from an MFDataClass with more than 0 properties.", self, classToCheck];
        }
        
        /// Break
        if (classToCheck == MFDataClassBase.class) { break; } /// Found MFDataClassBase
        if (classToCheck == nil || classToCheck == NSObject.class) { assert(false); break; } /// Found root class, this can never happen (as of Oct 2024)
        
        /// Iterate
        classToCheck = class_getSuperclass(classToCheck);
        
    }
    
    /// Validate properties
    for (NSString *propertyName in self.allPropertyNames) {

        /// Get typeEncoding
        NSString *propertyAttributes = [self attributesForProperty:propertyName];
        NSString *typeEncoding = typeEncodingForProperty(propertyAttributes);
        if (typeEncoding == nil) {
            [NSException raise:NSInternalInconsistencyException format:@"Couldn't get type encoding for property %@.%@ with attributes %@ (This should never happen, no matter how the MFDataClass is defined.)", self, propertyName, propertyAttributes];
        }
        
        /// Validate nullable/nonnull property attribute
        ///     Keep in mind: (Oct 2024)
        ///         This validates the nullability that's passed into the `@implementation` macro (`MFDataClassImplementX()`)
        ///         But meanwhile, all the native objc warnings as well as the way that the dataclass is imported into Swift depends on the nullability specified in the `@@interface` macro (`MFDataClassInterfaceX()`)
        ///         -> ! Keep the nullability in the `@@implementation` and `@@interface` macros synchronized!
        ///             ... otherwise, these validations here won't ensure correctness.
        BOOL isNullableType = propertyHasTypeThatSupportsNullability(typeEncoding);
        NSString *rawNullability = [self rawNullabilityOfProperty:propertyName];
        if (rawNullability == nil) {
            [NSException raise:NSInternalInconsistencyException format:@"Raw nullability string of property %@.%@ was nil. (This should never happen, no matter how the MFDataClass is defined.)", self, propertyName];
        }
        if (isNullableType && ([rawNullability isEqual:@""] || [rawNullability isEqual:@"null_unspecified"])) {
            [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ has unspecified nullability (raw nullability value: '%@') even though its type supports nullability. Due to the existence of NS_ASSUME_NONNULL, we cannot know at runtime whether the property is nullable or not if nullability is not specified. This could (theoretically) lead to bugs and inconsistencies because we won't be able to validate nullability inside `initWithCoder:`. Please explicitly specify the nullability in the MFDataClass definition to fix this.", self, propertyName, rawNullability];
        } else if (!isNullableType && ![rawNullability isEqual:@""]) {
            [NSException raise:NSInternalInconsistencyException format:@"Property %@.%@ has specified nullability even though its type does not support nullability. This should never happen (since the objc compiler doesn't even let you compile when you do this afaik)", self, propertyName];
        }
        if ([rawNullability isEqual:@"null_resettable"]) {
            [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ has null_resettable attribute. Don't know how to handle this. Needs additional testing.", self, propertyName];
        }
        
        /// Note: We don't need to validate the readwrite/readonly property attribute since there's nothing to do wrong there.
        /// Note: We don't need to validate the assign/strong/weak/copy property attributesince the objc compiler already validates the necessary stuff (objc doesn't let you use assign with objects, but forces you to use assign with non-objects)
        
        /// Validate property type
        NSString *propClassName = classNameForProperty([typeEncoding cStringUsingEncoding:NSUTF8StringEncoding]);
        
        if (propClassName != nil) {
            
            /// Property is an object
            if ([propClassName isEqual:@"id"]) { /// Our `classNameForProperty:` returns `id` to signal that the className is unspecified.
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ has an unspecified class type (likely declared using `id`.) Use a concrete class like `NSObject` instead. Otherwise we can't run type validation when decoding an instance of this object, and so we cannot decode using NSSecureCoding.", self, propertyName];
            }
            
            Class theClass = NSClassFromString(propClassName);
            if (theClass == nil) {
                [NSException raise:NSInternalInconsistencyException format:@"Failed to instantiate class for property %@.%@. propertyAttributes: %@, className: %@. Not sure if this can ever happen.", self, propertyName, propertyAttributes, propClassName];
            }
            
            NSArray<Protocol *> *protocols = @[@protocol(NSSecureCoding),
                                               @protocol(NSCopying),
                                               @protocol(NSObject)]; /// We can't really confirm that the object properly implements `isEqual:` and `hash` since they are part of the `NSObject` protocol which everybody implements;
            
            for (Protocol *protocol in protocols) {
                if (![theClass conformsToProtocol:protocol]) {
                    [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with class %@ does not conform to protocol: %@. This would silently break protocol conformance of the MFDataClass (%@). Please use another type for the property.", self, propertyName, propClassName, protocol, self];
                }
            }
            
        } else {
        
            /// Property is non-object-type
            ///     -> Check if we know how to handle this type
            ///     -> What we reallyyy want to know is whether Key-Value-Coding will auto-box these types in NSValue. If that's the case everything should work.
            ///         (Because NSValue adopts all the protocols we want: `NSSecureCoding`, `NSCopying`, `NSObject`)
            ///         -> However, I don't know how to check exactly which types will get autoboxed in NSValue. So these tests are kinda based on my gut feeling and stuff.
            ///
            ///     Documentation of c-type encodings:
            ///         1.NSHipster:  https://nshipster.com/type-encodings/
            ///         2. Apple Docs: https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1
            
            ///     Note that we're disallowing many c types
            ///         ... but we let any **structs** and **numbers** pass.
            ///         Numbers should always work. (They're always auto-boxed in `NSNumber` by KVC)
            ///         Structs are normally auto-boxed by KVC. But I suspect that some complex structs with won't be supported? I don't know how to check that, though.
            
            if ([typeEncoding isEqual:@"@?"]) { /// block ptr
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a block pointer.   Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding isEqual:@"^?"]) { /// function ptr
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a function ptr.    Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding isEqual:@"^v"]) { /// void ptr
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a void pointer.    Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding characterAtIndex:0] == '^') { /// any ptr
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a raw pointer.     Not sure how to handle that", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding characterAtIndex:0] == '(') { /// union
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a union.           They are incompatible with KVC afaik.", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding characterAtIndex:0] == '[') { /// c array
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a c array.         Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding characterAtIndex:0] == '*') { /// c string
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a raw c string.    Not sure how to handle that", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding characterAtIndex:0] == 'b') { /// bit field
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a bit field.       Not sure how to handle that", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding characterAtIndex:0] == '#') { /// Class object
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a class object.    Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding characterAtIndex:0] == ':') { /// SEL
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a SEL.             Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding characterAtIndex:0] == '?') { /// Unknown
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be 'unknown'.         Not sure how to handle that.", self, propertyName, typeEncoding];
            }
        }
    }
    
    #endif
}

// - MARK: Protocol implementations

// MARK: NSCoding / NSSecureCoding protocol
    
+ (BOOL)supportsSecureCoding {
    /// I think we only support secureCoding if all properties have types that also conform to `NSSecureCoding`? Not sure what happens if this is not the case. But I thinkkk it would just fail gracefully, and still work when we turn `.requiresSecureCoding` off.
    ///     Update: In `+ load` we now do validation that properties support `NSSecureCoding`.
    return YES;
}

- (void)encodeWithCoder:(NSCoder *)coder {
    for (NSString *key in self.class.allPropertyNames) {
        id value = [self valueForKey:key];
        if (value) {
            [coder encodeObject:value forKey:key];
        }
    }
}
    
- (instancetype)initWithCoder:(NSCoder *)coder {
    
    /// Also see:
    ///     Apple WWDC 2018 Session 222 "Data You Can Trust": https://devstreaming-cdn.apple.com/videos/wwdc/2018/222krhixqaeggyrn33/222/222_hd_data_you_can_trust.mp4?
    ///         (This has been deleted from the Apple page for some reason, but their CDN still has the video)
    ///         -> This explains how and why to use `NSSecureCoding`
    ///
    /// On `NSSecureCoding`: (Last updated: Oct 2024)
    ///     I thought about this a bit and I think NSSecureCoding and how Apple communicates it is a bit weird / ineffective.
    ///     As I understand the core problem, basically there's a possibility that, between encoding and decoding an object, the encoded data could be manipulated by attackers in malicious ways. (serialization attack)
    ///     1. First of all, when your encoded data comes from a controlled, trusted source, (like from the user's library as it is the case for the config.plist file of Mac Mouse Fix), then validating the high level data like this is unnecessary.
    ///         That's because accidental data corruption would result in an invalid archive with extremely high likelyhood, so if you successfully unarchived your entire object graph, any further validation is only helpful for guarding against *deliberate* tampering by hackers - which is not a concern if the data comes from a trusted source.
    ///     2. Secondly, the `NSSecureCoding` documentation only speaks about validating that the decoded object's `classes` are what you expect.
    ///         However, this is not enough to prevent malicious tampering. For example if you decode a URL, that could be replaced by a hacker with a phishing URL and even if you implement `NSSecureCoding` exactly as advertised by Apple, that wouldn't help at all.
    ///         For some reason Apple only focuses on class-substitution attacks with `NSSecureCoding`.
    ///             There is one thing that's special about class-substitution-attacks which warrants implementing a special API, but doesn't seem to warrant focusing the entire `NSSecureCoding` protocol around it and pushing everyone to adopt it:
    ///                 The thing that's special is that: For all other types of validation except for matching-class-validation, you can make the decoding watertight against attackers by validating the decoded values *after* they come out of the decoder.
    ///                 But when decoding objects, their `- init` or `+ load` methods could already produce side-effects before you can validate whether the object is of the right class.
    ///                 -> So this opens a possible attack vector, (which would be very hard to do anything useful with since the hacker could still only instantiate classes which are already defined in your application, and could only work with their `- initWithCoder`, `+ initialize` or `+ load` methods.)
    ///                     This attack-vector cannot be closed by traditional validation methods where you validate the class *after* it comes out of the decoder so that's why `NSCoder - decodeObjectOfClass:` exists. It makes sense.
    ///     -> So I understand why `decodeObjectOfClass:` exists - it makes it possible to make your decoding process *totally* watertight against attackers, *if* you use it alongside more extensive validation.
    ///     -> But the only thing that `NSSecureCoding` does is tell/require you to use `decodeObjectOfClass:`. And Apple seems to basically push everybody to use `NSSecureCoding` all the time.
    ///         This doesn't make sense to me because:
    ///         If you have a trusted source for the data, `decodeObjectOfClass:`/`NSSecureCoding` is basically entirely unnecessary.
    ///         If you have an untrusted source, just adopting `decodeObjectOfClass:`/`NSSecureCoding` is by far not enough to make things really watertight against attacks, but Apple doesn't seem to mention this in the `NSSecureCoding` docs.
    ///
    /// About the validation we do here: (Last updated: Oct 2024)
    ///     For `MFDataClass` we're validating **nullability** and **type** of every decoded property.
    ///     As explained in the `NSSecureCoding` section, this is pretty unnecessay unless we're decoding data from an untrusted source.
    ///     If we are decoding data from an untrusted source, then we should probably do additional, custom validation, because the nullability and type checks are not enough to make things actually secure.
    ///         -> We could do additional, custom validation by creating a category for an `MFDataClass`.)
    ///         -> Untrusted data is not a concern for Mac Mouse Fix currently.
    ///             But perhaps in the future it will be? E.g. if we promote sharing config.plist files between users?
    ///
    /// Update:
    ///     Actually, I can think of another reason that our nullability and type validation could be useful aside from protecting against hacker attacks: When you change the layout of an MFDataClass between MMF versions.
    ///     In this case, ideally you would version your MFDataClasses and then validate that the version number matches. However, in the absence of deliberate versioning, our nullability and type checks should at least prevent loading of outdated MFDataClasses from producing any crashes in the code due to unexpected nil values or unexpected types inside the MFDataClass.
    ///
    
    self = [super init];
    if (!self) return nil;
    
    for (NSString *key in self.class.allPropertyNames) {
        
        if (coder.requiresSecureCoding == NO) {
            
            /// Normal decoding
            ///  -> Do absolutely no validation
            
            id _Nullable value = [coder decodeObjectForKey:key];
            [self setValue:value forKey:key];
            
        } else {
        
            /// 'Secure' decoding
        
            /// Guard valueNotFound
            if (![coder containsValueForKey:key]) {
                assert(false);
                [coder failWithError:[NSError errorWithDomain:NSCocoaErrorDomain code:NSCoderValueNotFoundError userInfo:@{ @"message": stringf(@"No value found while decoding %@.%@", [self class], key) }]];
                return nil;
            }
            
            /// Get typeEncoding
            NSString *propertyAttributes = [[self class] attributesForProperty:key];
            NSString *typeEncoding = typeEncodingForProperty(propertyAttributes);
            
            /// Guard no typeEncoding
            if (typeEncoding == nil) {
                assert(false);
                [coder failWithError:[NSError errorWithDomain:@"MFPlaceholderErrorDomain" code:123456789 userInfo:@{ @"message": stringf(@"Internal inconsistency: Couldn't get typeEncoding for property %@.%@ with attributes: %@", [self class], key, propertyAttributes) }]];
                return nil;
            }
            
            /// Get className
            NSString *className = classNameForProperty([typeEncoding cStringUsingEncoding:NSUTF8StringEncoding]);
            
            /// Edge case: unspecified object type
            ///     If the property is declared with an unspecified object type, then our type validation code won't work.
            ///     We're already validating this in `+ load` - so this should never happen.
            if ([className isEqual:@"id"]) {
                assert(false);
                [coder failWithError:[NSError errorWithDomain:@"MFPlaceholderErrorDomain" code:123456789 userInfo:@{ @"message": stringf(@"Internal inconsistency: Property %@.%@ with attributes: %@ seems to have unspecified object type (likely declared with `id`). This should never happen since we should've already checked for this in `+ load`.", [self class], key, propertyAttributes) }]];
                return nil;
            }
            
            /// Parse className
            BOOL isNonObjectValue = className == nil; /// If the className is nil, that means the property is a non-object value - that's how our `classNameForProperty()` function works.
            
            /// Get expectedClass
            Class expectedClass;
            if (isNonObjectValue)  {
                expectedClass = [NSValue class]; /// Non-object values come out of our decoder boxed inside an NSValue (That's because when *en*coding an MFDataClass instance, we use the KVC API to get the property values, and this API auto-boxes non-object values in `NSValue`, and so that's how we pass them into the encoder.)
            } else {
                expectedClass = NSClassFromString(className);
            }
            
            /// Decode value
            ///     (Using NSSecureCoding method)
            ///     The decoder will `failWithError:` automatically, if there's a type mismatch or the decoded object does not implement `NSSecureCoding`.
            ///     -> That's if if `coder.requiresSecureCoding == true`
            ///     -> If `coder.requiresSecureCoding == false` then this would do no checks while decoding the object. `expectedClass` would be ignored.
            ///
            id _Nullable value = [coder decodeObjectOfClass:expectedClass forKey:key];
            
            /// Guard decoding error
            ///     Depending on the `coder.decodingFailurePolicy`, `decodeObjectOfClass:` might either throw and error or just set `coder.error` and then continue execution, so we check for that here.
            if (coder.error != nil) {
                assert(false); /// We don't need to call `failWithError:` since the coder already has an error.
                return nil;
            }
            
            /// Check type
            if (((false)) && !coder.requiresSecureCoding) { /// Why `((false))`?: If `requiresSecureCoding` is true, `decodeObjectOfClass:` will have already checked the type, so we can skip this. Update: These checks are not helpful if `requiresSecureCoding` is turned off. See the discussion above on `NSSecureCoding`
                if (value != nil && ![value isKindOfClass:expectedClass]) {
                    assert(false);
                    [coder failWithError:[NSError errorWithDomain:NSCocoaErrorDomain code:NSCoderInvalidValueError userInfo:@{ @"message": stringf(@"Type mismatch while decoding %@.%@: Expected: %@. Found: %@", [self class], key, expectedClass, [value class]) }]];
                    return nil;
                }
            }
            
            /// Get nullability
            BOOL isAllowedToBeNil = [[self class] propertyIsAllowedToBeNil:key];
            
            /// Check nullability
            if ((value == nil) && !isAllowedToBeNil) {
                assert(false);
                [coder failWithError:[NSError errorWithDomain:NSCocoaErrorDomain code:NSCoderInvalidValueError userInfo:@{ @"message": stringf(@"Unexpectedly found nil while decoding non-nullable property %@.%@.", [self class], key) }]];
                return nil;
            }
            
            /// Check boxed type
            if (isNonObjectValue) {
            
                /// Cast to NSValue
                NSValue *nsValue = (NSValue *)value;
                
                /// Get type encodings
                const char *propertyTypeEncoding = [typeEncoding cStringUsingEncoding:NSUTF8StringEncoding];
                const char *nsValueTypeEncoding = [nsValue objCType];
                
                /// Special case: Booleans
                if (strcmp(propertyTypeEncoding, "B") == 0) { /// For boolean properties, the decoded NSValue seems to just use 'c' (char) while the property encoding uses 'B' (boolean). I also checked `ivar_getTypeEncoding()` and it's also `B` so won't help.
                    propertyTypeEncoding = "c";
                }
                
                /// Check if types match
                if (strcmp(nsValueTypeEncoding, propertyTypeEncoding) != 0) {
                    assert(false);
                    [coder failWithError:[NSError errorWithDomain:NSCocoaErrorDomain code:NSCoderInvalidValueError userInfo:@{ @"message": stringf(@"Type mismatch while decoding non-object property %@.%@. Expected: %s. Found: %s", [self class], key, propertyTypeEncoding, nsValue.objCType) }]];
                    return nil;
                }
            }
            
            /// Passed all security checks!
            [self setValue:value forKey:key];
        }
    }
    
    return self;
}

// MARK: NSCopying Protocol
- (id)copyWithZone:(NSZone *)zone {
    
    /// Notes:
    /// - By copying all properties, we do a 'deeper' copy than e.g. `[NSArray -copy]`.
    ///     Perhaps we can rationalize this by thinking: MFDataClass is like an "object-version" of a struct. Structs behave like they are 'deep-copying', so MFDataClass should, as well. Also, shallow copying and then swapping / adding some members to the copy feels more useful on NSArray, since it's a 'more dynamic' datatype (?)
    /// - (Oct 2024) Immutable values can just return themselves instead of a copy and noone will notice. Could we determine whether we are immutable and leverage that for optimization? (We probably could by checking `property_getAttributes()` for whether all our properties are readonly.)

    MFDataClassBase *copy = [[[self class] allocWithZone:zone] init];
    if (copy) {
        for (NSString *key in self.class.allPropertyNames) {
            id value = [self valueForKey:key];
            if (value) {
                [copy setValue:[value copyWithZone:zone] forKey:key]; /// Non-object-specific logic is not necessary, since `NSValue` and `NSNumber` (which our non-object values will be boxed in by KVC) adopt the `NSCopying` protocol. But also, NSNumber and NSValue are immutable so `- copyWithZone:` might just `return self` and not do anything and not cause any overhead?
            }
        }
    }
    return copy;
}

// MARK: Override NSObject Equality/Hashing methods:
- (BOOL)isEqual:(id)object {
    
    /// Trivial cases
    if (object == nil) {
        return NO;
    }
    if (self == object) {
        return YES;
    }
    if (object_getClass(self) != object_getClass(object)) { /// Note: Is this a valid way to compare class-equality? TODO: Check our Swizzling code to see how we do it there.
        return NO;
    }
    
    /// Unwrap other
    MFDataClassBase *other = (MFDataClassBase *)object;
    
    /// Compare propertyValues
    if (![self.propertyValuesForEqualityComparison isEqual:other.propertyValuesForEqualityComparison]) {
        return NO;
    }
    
    /// Passed all tests!
    return YES;
}

- (NSUInteger)hash {
    NSUInteger result = self.propertyValuesForEqualityComparison.hash;
    return result;
}

/// MARK: Utility

+ (NSArray<NSString *> *_Nonnull)allPropertyNames {
    
    /// Notes:
    /// - This is used by almost all other methods - We could maybe do some caching here to speed things up
    ///     Don't forget: If we cache the result and just return that every time then this will break if properties are added at runtime. (Which I'm not sure is relevant for MFDataClass)
    
    NSMutableArray *result = [NSMutableArray array];
    
    unsigned int propertyCount, i;
    objc_property_t *properties = class_copyPropertyList([self class], &propertyCount);
    
    for (i = 0; i < propertyCount; i++) {
        objc_property_t property = properties[i];
        const char *propName = property_getName(property);
        if (propName) {
            [result addObject:[NSString stringWithUTF8String:propName]];
        }
    }
    
    free(properties);
    
    return result;
}

- (NSArray<id> *_Nonnull)allPropertyValues {
    
    NSMutableArray *result = [NSMutableArray array];
    
    for (NSString *propertyName in self.class.allPropertyNames) {
        id propertyValue = [self valueForKey:propertyName];
        propertyValue = propertyValue ?: [NSNull null]; /// Adding nil into an array causes an exception!
        [result addObject:propertyValue];
    }
    
    return result;
}

- (NSArray<id> *_Nonnull)propertyValuesForEqualityComparison {

    /// Client code can override this (in a category) to easily change the definition of equality
    ///     (This will also automatically change `hash`, so that hashing and equality definitions match.)
    ///     On property order:
    ///         The order of the property values in the returned array needs to always be the same, otherwise our equality and hash methods that depend on this will break.
    ///         For the default implementation this should be ensured since the underlying function `class_copyPropertyList()` seems to output the properties in deterministic order based on my testing.
    ///         If order ever does cause breakage, perhaps we could return an `NSSet` instead of `NSArray`, or sort inside `allPropertyNames` before returning - so that we ensure we always access the properties in the same order.
    ///
    ///     On nil:
    ///         If you override this, don't forget to substitute nil values with `[NSNull null]`. Trying to insert nil into an array will crash and stuff!
    
    return [self allPropertyValues];
}

- (NSDictionary<NSString *, NSObject *> *_Nonnull)asDictionary {
    
    /// Using the KVC method `setValuesForKeysWithDictionary:` for the 'opposite' of this method. (Although that probably doesn't have type and nullability checks so maybe shouldn't be used)
    ///     Sidenote: `dictionaryWithValuesForKeys:` will automatically substitue `nil` for `NSNull`
    
    NSDictionary *result = [self dictionaryWithValuesForKeys:self.class.allPropertyNames];
    return result;
}

/// MARK: - Property analysis
///     We use this for validation in `- initWithCoder:`
///     Big picture: (As of Oct 2024)
///         Here, we implement functions to analyze **nullability** and **type** of a property.
///         This is quite a bit of code, but it is really only really used for validation of the decoded data inside `initWithCoder:`
///         - but this validation might not even be helpful in practise -> See discussion inside `initWithCoder:` for more.
///     Sidenote:
///         (We're technically also using this property analysis stuff inside the `+ load` validation, but the `+ load` validation just validates that the `initWithCoder:` validation is going to work.)

NSString *_Nullable typeEncodingForProperty(NSString *_Nullable propertyAttributes) {
    
    /// Get type encoding for a string obtained with `property_getAttributes()`
    ///     See the Apple docs for an explanation of the attributeString format: https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101
    ///     Discussion:
    ///         The docs linked above seem to be outdated. They claim that between the first `T` and `,` of a property's attribute string (obtained with `property_getAttributes()`) you'll find the `@encode()` string of the property's type.
    ///         However, there seems to be a discrepancy, as `@enconde()` always just returns `@` for any object, while the property's attribute string will contain additional information about the class and protocols of a given object.
    ///         For example you might find the following substring in the attribute string:`@"T@"NSView<NSSecureCoding><NSCopying>",`. If the docs were accurate this should instead just be `@"T@,`, because `@encode()` just returns `@`.
    
    /// Check nil
    if (propertyAttributes == nil) return nil;
    
    /// Extract the type encoding string
    NSInteger typeEncodingPre = [propertyAttributes rangeOfString:@"T" options:NSLiteralSearch].location;
    NSInteger typeEncodingPost = [propertyAttributes rangeOfString:@"," options:NSLiteralSearch].location;
    if (typeEncodingPre == NSNotFound || typeEncodingPost == NSNotFound) {
        assert(false); /// I think this should never happen unless objc runtime is broken or we got a wrong input value
        return nil;
    }
    NSInteger typeEncodingStart = typeEncodingPre + 1;
    NSInteger typeEncodingEnd = typeEncodingPost - 1;
    if (typeEncodingEnd - typeEncodingStart <= -1) {
        assert(false); /// Type encoding has *less* than zero characters. Don't think this can ever happen except if objc runtime is broken or we get wrong input. Think this can only happen if `,` occurs before `T` in the string.
        return nil;
    }
    
    NSRange typeEncodingRange = NSMakeRange(typeEncodingStart, typeEncodingEnd - typeEncodingStart + 1);
    NSString *typeEncoding = [propertyAttributes substringWithRange:typeEncodingRange];
    
    /// Return
    return typeEncoding;
}

+ (NSString *_Nullable)attributesForProperty:(NSString *_Nullable)propertyName {
    if (propertyName == nil) return nil;
    objc_property_t property = class_getProperty(self, [propertyName cStringUsingEncoding:NSUTF8StringEncoding]); /// Why UTF8? Quote from Objective-C runtime docs: `All char * in the runtime API should be considered to have UTF-8 encoding.`
    if (property == nil) return nil;
    const char *attributes = property_getAttributes(property);
    if (attributes == NULL) return nil;
    return @(attributes);
}

/// MARK: Property-nullability analysis

+ (BOOL)propertyIsAllowedToBeNil:(NSString *)propertyName {
    
    NSString *nullabilityString = [self rawNullabilityOfProperty:propertyName];
    BOOL result = [nullabilityString isEqual:@"nullable"];
    
    return result;
    
    /// Notes:
    ///     We used to do more complex stuff here,
    ///         but now we're validating a lot of nullability stuff in `load` making it unnecessary.
    ///
    ///     Here are the old notes from when we did more complex stuff:
    ///     The raw `nullabilityString` can be empty (`@""`).
    ///     The meaning of this is ambiguous:
    ///         For non-nullable types the nullabilityString has to be empty.
    ///         For nullable types, we assume that emptyString means that the property is nullable.
    ///         -> However, this would break if `NS_ASSUME_NONNULL` was set where the MFDataClass was defined. In that case emptyString would mean the property is nonnull, and we couldn't detect this here.
    ///     Update:
    ///         Now, inside `+ load`, we validate that the nullabilityString is empty if and only if the property type does *not* support nullability. For types that support nullability, nullability needs to be specified explicitly. This gets rid of the ambiguity of `@""`, letting us simplify this code a lot.
}

+ (NSString *_Nullable)rawNullabilityOfProperty:(NSString *_Nullable)propertyName {
    ///
    /// Returns stringified version of the nullability attribute - exactly as it's been passed into the `MFDataClassX(...)` macro.
    ///
    /// Possible outputs:
    ///     ```
    ///     - @"nullable"
    ///     - @"nonnull"
    ///     - @"null_resettable"        (Don't use this with MFDataClass)
    ///     - @"null_unspecified"       (Don't use this with MFDataClass)
    ///     - @""                       (We return this if: Nullability was left empty in the property definition)
    ///     - nil                       (We return this if: No property was found for `propertyName`)
    ///     ```
    ///
    /// We just raise an exception / return nil here because implementing this properly here is impossible.
    /// Instead we override this method in the `MFDataClassImplementX()` macros.
    /// -> That's necessary because nullability info is not accessible through objc runtime introspection.
    /// -> Info about *all other* property attributes seems to be available through runtime introspection (e.g. whether the property is `strong`, `assign`, `nonatomic`, what type it has, etc.)
    ///     -> That other info can be accessed at runtime through `property_getAttributes()`
    ///
    /// On nullable input:
    ///     We use the `propertyName` input value as a dictionary-key in the subclass overrides of this method. When indexing an NSDictionary with nil it seems to just returns nil. So this should be safe.
    
    [NSException raise:NSInternalInconsistencyException format:@"MFDataClassX(...) macros must override %@ without calling super.", NSStringFromSelector(_cmd)];
    return nil; /// This line will never be reached
}

/// MARK: Property-type analysis

BOOL propertyHasTypeThatSupportsNullability(NSString *_Nullable typeEncoding) {
    
    /// Discussion:
    ///     As far as I know, object pointers and regular pointers support nullability, but nothing else does.
    ///     Object pointers are identified in the type encoding by `@`, while pointers are identified by `^`
    ///     Interesting/special cases are function pointers (identified by `^?`) and block pointers (identified by `@?`). - those are also nullable. I don't think anything else is.
    ///     Note that opaque types like `CFStringRef` are actually struct pointers, so their type encoding will contain `^`, so this function will also categorize them as 'supports nullability' which is correct.
    
    if (typeEncoding == nil || typeEncoding.length == 0) {
        assert(false);
        return NO;
    }
    
    unichar firstChar = [typeEncoding characterAtIndex:0];
    BOOL result = firstChar == '^' || firstChar == '@';
    
    return result;
}

NSString *_Nullable classNameForProperty(const char *_Nullable typeEncoding) {
    
    /// This gets the objc class name for a string obtained with `typeEncodingForProperty()`
    ///
    /// Possible outputs:
    ///     1. The class name for the @property whose type encoding is `typeEncoding`
    ///     2. `@"id"` (if the property is an object of unspecified type)
    ///         (Note that `id` is not a valid class name and will produce nil when passed to `NSClassFromString()`. In contrast, all other non-nil return values should produce valid `Class` object when passed to `NSClassFromString()`)
    ///     3. `nil` (if the property has a non-object type, or no property was found for `propertyName`)
    ///
    ///     Examples:
    ///         - For an *object* property:
    ///             `@property (strong, nonatomic) NSString *coolString;`
    ///             This function would return  `@"NSString"`
    ///
    ///         - For a *non-object* property:
    ///             `@property (assign, nonatomic) int coolInt;`
    ///             This function would return `nil`
    ///
    ///         - For a property with *protocol conformance*:
    ///             `@property (strong, nonatomic) NSObject<NSSecureCoding, NSCopying> *coolCodableObject;`
    ///             This function would strip out the protocol info and return `@"NSObject"`
    ///
    ///         - For a property with unspecified object type (id):
    ///             `@property (strong, nonatomic) id<NSCopying> coolCopyingObject;`
    ///             This function would return `@"id"`
    ///
    /// TODO: Perhaps use NSScanner instead of this low-level c-string stuff
    ///     (Might be easier.)
    
    
    /// Check NULL
    if (typeEncoding == NULL) { /// `strlen()` segfaults if you pass it NULL
        return nil;
    }
        
    /// Extract the classEncoding from the typeEncoding
    ///     Or return nil if the typeEncoding does not describe a class (If it does describe a class it follows the format `@"..."`)
    long typeEncodingLen = strlen(typeEncoding);
    if (typeEncodingLen < 3) return nil;
    if (typeEncoding[0] != '@' || typeEncoding[1] != '"' || typeEncoding[typeEncodingLen-1] != '"') return nil;
    char classEncoding[typeEncodingLen - 2]; /// The classEncoding buffer will contain the typeEncoding string minus the `@`, `"`, and `"` characters, plus a zero-terminator (`'\0'`)
    strncpy(classEncoding, typeEncoding + 2, typeEncodingLen - 3);
    classEncoding[typeEncodingLen - 3] = '\0';
    
    /// Remove protocol conformance information
    ///     Sidenote:
    ///         Protocol conformance (such as `NSObject<NSSecureCoding> *`) shows up in the `typeEncoding`
    ///         But generic types (such as `NSArray<NSString *> *`) do *not* show up in the `typeEncoding`
    ///         -> even though both use very similar syntax, generics seem to be compile-time-only
    char *protocolInfoStartChr = strchr(classEncoding, '<');
    if (protocolInfoStartChr != NULL) {
        long protocolInfoStartIdx = protocolInfoStartChr - classEncoding;
        classEncoding[protocolInfoStartIdx] = '\0'; /// Cut the string short by inserting a zero-terminator
    }
    
    /// Guard empty string
    ///     Empty `classEncoding` means the type is an object of unspecified type
    if (strlen(classEncoding) == 0) return @"id";
    
    /// Validate
    assert(NSClassFromString(@(classEncoding)) != nil);
    
    /// Return
    return @(classEncoding);
}

@end
